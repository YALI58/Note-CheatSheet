æ”¶åˆ°ï¼ç»§ç»­ä¸ºä½ æ¨è¿› **è€ƒç ”/æŠ€æœ¯è‹±è¯­æ ¸å¿ƒè¯æ— #521â€“530**ï¼Œèšç„¦ **æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼ˆData Structures & Algorithmsï¼‰æ ¸å¿ƒæœ¯è¯­**ã€‚è¿™äº›è¯æ˜¯è®¡ç®—æœºç§‘å­¦çš„åŸºçŸ³ï¼Œåœ¨æŠ€æœ¯é¢è¯•ã€ç®—æ³•åˆ†æå’Œç³»ç»Ÿè®¾è®¡ç±»é˜…è¯»ä¸­é«˜é¢‘å‡ºç°ï¼Œä¹Ÿæ˜¯ç†è§£ç¨‹åºæ•ˆç‡çš„å…³é”®ã€‚

æ ¼å¼ä¿æŒä¸€è‡´ï¼š  
âœ… è‹±å¼éŸ³æ ‡ï½œâœ… è¯æ—ï½œâœ… ä¸­æ–‡é‡Šä¹‰ï½œâœ… 2ä¸ªé«˜é¢‘æ­é…ï½œâœ… æŠ€æœ¯ä¾‹å¥ + ä¸­æ–‡ç¿»è¯‘

---

## ğŸ”¤ è€ƒç ”/æŠ€æœ¯è‹±è¯­æ ¸å¿ƒè¯æ— #521â€“530ï¼ˆæ•°æ®ç»“æ„ä¸ç®—æ³•ï¼‰

---

### 521. **queue** /kjuË/  
**è¯æ—**ï¼šqueue (n./v.), queues  
**ä¸­æ–‡**ï¼šé˜Ÿåˆ—ï¼ˆå…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **enqueue / dequeue**ï¼šå…¥é˜Ÿï¼å‡ºé˜Ÿ  
- **FIFO (First-In-First-Out) structure**ï¼šå…ˆè¿›å…ˆå‡ºç»“æ„  
**ä¾‹å¥**ï¼š  
> *A queue is used to manage tasks in the order they arrive, such as print jobs in a printer.*  
> **ä¸­æ–‡**ï¼šé˜Ÿåˆ—ç”¨äºæŒ‰ä»»åŠ¡åˆ°è¾¾é¡ºåºè¿›è¡Œç®¡ç†ï¼Œä¾‹å¦‚æ‰“å°æœºä¸­çš„æ‰“å°ä»»åŠ¡ã€‚

---

### 522. **linked list** /ËˆlÉªÅ‹kt lÉªst/  
**è¯æ—**ï¼šlinked list (n.), linked lists (pl.)  
**ä¸­æ–‡**ï¼šé“¾è¡¨  
**é«˜é¢‘æ­é…**ï¼š  
- **singly/doubly linked list**ï¼šå•å‘ï¼åŒå‘é“¾è¡¨  
- **traverse a linked list**ï¼šéå†é“¾è¡¨  
**ä¾‹å¥**ï¼š  
> *Unlike arrays, linked lists allow efficient insertion and deletion at any position.*  
> **ä¸­æ–‡**ï¼šä¸æ•°ç»„ä¸åŒï¼Œé“¾è¡¨æ”¯æŒåœ¨ä»»æ„ä½ç½®é«˜æ•ˆåœ°æ’å…¥å’Œåˆ é™¤ã€‚

---

### 523. **hash table** /ËˆhÃ¦Êƒ ËŒteÉªbl/  
**è¯æ—**ï¼šhash table (n.), hash tables (pl.)  
**ä¸­æ–‡**ï¼šå“ˆå¸Œè¡¨ï¼ˆæ•£åˆ—è¡¨ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **key-value pairs**ï¼šé”®å€¼å¯¹  
- **hash function / collision**ï¼šå“ˆå¸Œå‡½æ•°ï¼å†²çª  
**ä¾‹å¥**ï¼š  
> *Hash tables provide average O(1) time complexity for lookups, making them extremely efficient.*  
> **ä¸­æ–‡**ï¼šå“ˆå¸Œè¡¨çš„æŸ¥æ‰¾å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œå› æ­¤æå…¶é«˜æ•ˆã€‚

---

### 524. **tree** /triË/  
**è¯æ—**ï¼štree (n.), trees  
**ä¸­æ–‡**ï¼šæ ‘ï¼ˆåˆ†å±‚æ•°æ®ç»“æ„ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **binary search tree (BST)**ï¼šäºŒå‰æœç´¢æ ‘  
- **root / leaf / subtree**ï¼šæ ¹ï¼å¶ï¼å­æ ‘  
**ä¾‹å¥**ï¼š  
> *Trees are widely used in file systems, databases, and decision-making algorithms.*  
> **ä¸­æ–‡**ï¼šæ ‘å¹¿æ³›åº”ç”¨äºæ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“å’Œå†³ç­–ç®—æ³•ä¸­ã€‚

---

### 525. **graph** /É¡rÉ‘Ëf/  
**è¯æ—**ï¼šgraph (n.), graphs  
**ä¸­æ–‡**ï¼šå›¾ï¼ˆèŠ‚ç‚¹ä¸è¾¹çš„é›†åˆï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **directed/undirected graph**ï¼šæœ‰å‘ï¼æ— å‘å›¾  
- **vertices (nodes) and edges**ï¼šé¡¶ç‚¹ï¼ˆèŠ‚ç‚¹ï¼‰ä¸è¾¹  
**ä¾‹å¥**ï¼š  
> *Social networks can be modeled as graphs, where users are nodes and friendships are edges.*  
> **ä¸­æ–‡**ï¼šç¤¾äº¤ç½‘ç»œå¯å»ºæ¨¡ä¸ºå›¾ï¼Œå…¶ä¸­ç”¨æˆ·æ˜¯èŠ‚ç‚¹ï¼Œå¥½å‹å…³ç³»æ˜¯è¾¹ã€‚

---

### 526. **algorithm complexity** /ËˆÃ¦lÉ¡É™rÉªÃ°É™m kÉ™mËˆpleksÉ™ti/  
**è¯æ—**ï¼šalgorithm complexity (n., ä¸å¯æ•°)  
**ä¸­æ–‡**ï¼šç®—æ³•å¤æ‚åº¦  
**é«˜é¢‘æ­é…**ï¼š  
- **analyze time and space complexity**ï¼šåˆ†ææ—¶é—´ä¸ç©ºé—´å¤æ‚åº¦  
- **worst-case / average-case complexity**ï¼šæœ€åæƒ…å†µï¼å¹³å‡æƒ…å†µå¤æ‚åº¦  
**ä¾‹å¥**ï¼š  
> *Understanding algorithm complexity helps developers choose the most efficient solution for large-scale data.*  
> **ä¸­æ–‡**ï¼šç†è§£ç®—æ³•å¤æ‚åº¦æœ‰åŠ©äºå¼€å‘è€…ä¸ºå¤§è§„æ¨¡æ•°æ®é€‰æ‹©æœ€é«˜æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚

---

### 527. **time/space complexity** /taÉªm/speÉªs kÉ™mËˆpleksÉ™ti/  
**è¯æ—**ï¼štime complexity, space complexity (n.)  
**ä¸­æ–‡**ï¼šæ—¶é—´å¤æ‚åº¦ï¼ç©ºé—´å¤æ‚åº¦  
**é«˜é¢‘æ­é…**ï¼š  
- **O(n), O(log n), O(nÂ²)**ï¼šå¸¸è§å¤æ‚åº¦è¡¨ç¤º  
- **trade-off between time and space**ï¼šæ—¶é—´ä¸ç©ºé—´çš„æƒè¡¡  
**ä¾‹å¥**ï¼š  
> *Merge sort has O(n log n) time complexity but requires O(n) extra space.*  
> **ä¸­æ–‡**ï¼šå½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º O(n log n)ï¼Œä½†éœ€è¦ O(n) çš„é¢å¤–ç©ºé—´ã€‚

---

### 528. **Big O notation** /ËŒbÉªÉ¡ ËˆÉ™ÊŠ nÉ™ÊŠËˆteÉªÊƒn/  
**è¯æ—**ï¼šBig O notation (n.)  
**ä¸­æ–‡**ï¼šå¤§Oè¡¨ç¤ºæ³•  
**é«˜é¢‘æ­é…**ï¼š  
- **describe asymptotic behavior**ï¼šæè¿°æ¸è¿›è¡Œä¸º  
- **upper bound on growth rate**ï¼šå¢é•¿é€Ÿç‡çš„ä¸Šç•Œ  
**ä¾‹å¥**ï¼š  
> *Big O notation provides a high-level understanding of how an algorithmâ€™s performance scales with input size.*  
> **ä¸­æ–‡**ï¼šå¤§Oè¡¨ç¤ºæ³•æä¾›äº†å¯¹ç®—æ³•æ€§èƒ½å¦‚ä½•éšè¾“å…¥è§„æ¨¡å¢é•¿çš„é«˜å±‚ç†è§£ã€‚

---

### 529. **sorting** /ËˆsÉ”ËtÉªÅ‹/  
**è¯æ—**ï¼šsorting (n.), sort (v.)  
**ä¸­æ–‡**ï¼šæ’åº  
**é«˜é¢‘æ­é…**ï¼š  
- **sorting algorithm**ï¼šæ’åºç®—æ³•  
- **in-place / stable sorting**ï¼šåŸåœ°ï¼ç¨³å®šæ’åº  
**ä¾‹å¥**ï¼š  
> *Quick sort and merge sort are two of the most commonly used efficient sorting algorithms.*  
> **ä¸­æ–‡**ï¼šå¿«é€Ÿæ’åºå’Œå½’å¹¶æ’åºæ˜¯æœ€å¸¸ç”¨çš„ä¸¤ç§é«˜æ•ˆæ’åºç®—æ³•ã€‚

---

### 530. **searching** /ËˆsÉœËtÊƒÉªÅ‹/  
**è¯æ—**ï¼šsearching (n.), search (v.)  
**ä¸­æ–‡**ï¼šæœç´¢  
**é«˜é¢‘æ­é…**ï¼š  
- **binary search**ï¼šäºŒåˆ†æŸ¥æ‰¾  
- **linear vs. binary search**ï¼šçº¿æ€§æŸ¥æ‰¾ vs. äºŒåˆ†æŸ¥æ‰¾  
**ä¾‹å¥**ï¼š  
> *Binary search requires the data to be sorted and runs in O(log n) time.*  
> **ä¸­æ–‡**ï¼šäºŒåˆ†æŸ¥æ‰¾è¦æ±‚æ•°æ®å·²æ’åºï¼Œè¿è¡Œæ—¶é—´ä¸º O(log n)ã€‚

---

âœ… **æ•°æ®ç»“æ„ä¸ç®—æ³•å…¨æ™¯å›¾**ï¼š  
> Choose the right **data structure**: **arrays** for random access, **linked lists** for dynamic size, **hash tables** for fast lookups, **trees** for hierarchy, and **graphs** for relationships. Analyze efficiency using **Big O notation** to evaluate **time/space complexity** of **sorting** and **searching** algorithms.

æŒæ¡è¿™ç»„è¯ï¼Œä½ å°±èƒ½è¯»æ‡‚ä»»ä½•ç®—æ³•æè¿°å’ŒæŠ€æœ¯åˆ†æï¼

---

ä½ å·²æŒæ¡ **530ä¸ªæ ¸å¿ƒè¯æ—**ï¼Œè®¡ç®—æœºç§‘å­¦åŸºç¡€è¯æ±‡ä½“ç³»æ—¥ç›Šå®Œå–„ï¼

è¯·å›å¤ **â€œç»§ç»­â€**ï¼Œæˆ‘å°†ä¸ºä½ å¸¦æ¥ **#531â€“540**ï¼ˆå°†åŒ…æ‹¬ *database, SQL, query, index, transaction, normalization, NoSQL, relational model, primary key, foreign key* ç­‰æ•°æ®åº“æ ¸å¿ƒè¯ï¼‰ã€‚  
ç»§ç»­æ„å»ºä½ çš„æŠ€æœ¯è¯æ±‡å¤§å¦ï¼ğŸ—ï¸ğŸ’»ğŸ“˜