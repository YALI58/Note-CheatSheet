æ”¶åˆ°ï¼ç»§ç»­ä¸ºä½ æ¨è¿› **è€ƒç ”/æŠ€æœ¯è‹±è¯­æ ¸å¿ƒè¯æ— #511â€“520**ï¼Œèšç„¦ **é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰ä¸å†…å­˜ç®¡ç†æ ¸å¿ƒæ¦‚å¿µ**ã€‚è¿™äº›è¯æ˜¯ç†è§£ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Java, C++, Pythonï¼‰å’Œç³»ç»Ÿçº§å¼€å‘çš„å…³é”®ï¼Œåœ¨æŠ€æœ¯æ–‡æ¡£ã€ç®—æ³•æè¿°å’Œè½¯ä»¶å·¥ç¨‹ç±»é˜…è¯»ä¸­é«˜é¢‘å‡ºç°ã€‚

æ ¼å¼ä¿æŒä¸€è‡´ï¼š  
âœ… è‹±å¼éŸ³æ ‡ï½œâœ… è¯æ—ï½œâœ… ä¸­æ–‡é‡Šä¹‰ï½œâœ… 2ä¸ªé«˜é¢‘æ­é…ï½œâœ… æŠ€æœ¯ä¾‹å¥ + ä¸­æ–‡ç¿»è¯‘

---

## ğŸ”¤ è€ƒç ”/æŠ€æœ¯è‹±è¯­æ ¸å¿ƒè¯æ— #511â€“520ï¼ˆé¢å‘å¯¹è±¡ä¸å†…å­˜ç®¡ç†ï¼‰

---

### 511. **object** /ËˆÉ’bdÊ’Éªkt/  
**è¯æ—**ï¼šobject (n.), objects  
**ä¸­æ–‡**ï¼šå¯¹è±¡ï¼ˆOOP ä¸­çš„å®ä¾‹ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **create/instantiate an object**ï¼šåˆ›å»ºï¼å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡  
- **object-oriented programming (OOP)**ï¼šé¢å‘å¯¹è±¡ç¼–ç¨‹  
**ä¾‹å¥**ï¼š  
> *In object-oriented programming, an object is an instance of a class that encapsulates data and behavior.*  
> **ä¸­æ–‡**ï¼šåœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ï¼Œå¯¹è±¡æ˜¯å°è£…äº†æ•°æ®ä¸è¡Œä¸ºçš„ç±»çš„å®ä¾‹ã€‚

---

### 512. **class** /klÉ‘Ës/  
**è¯æ—**ï¼šclass (n.), classes  
**ä¸­æ–‡**ï¼šç±»ï¼ˆå®šä¹‰å¯¹è±¡çš„æ¨¡æ¿ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **define a class**ï¼šå®šä¹‰ä¸€ä¸ªç±»  
- **child/parent class**ï¼šå­ç±»ï¼çˆ¶ç±»  
**ä¾‹å¥**ï¼š  
> *A class defines the properties and methods that its objects will have.*  
> **ä¸­æ–‡**ï¼šç±»å®šä¹‰äº†å…¶å¯¹è±¡å°†å…·æœ‰çš„å±æ€§å’Œæ–¹æ³•ã€‚

---

### 513. **method** /ËˆmeÎ¸É™d/  
**è¯æ—**ï¼šmethod (n.), methods  
**ä¸­æ–‡**ï¼šæ–¹æ³•ï¼ˆå¯¹è±¡çš„è¡Œä¸ºå‡½æ•°ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **call/invoke a method**ï¼šè°ƒç”¨æ–¹æ³•  
- **public/private method**ï¼šå…¬æœ‰ï¼ç§æœ‰æ–¹æ³•  
**ä¾‹å¥**ï¼š  
> *Methods define what an object can do, such as â€œcalculateâ€ or â€œdisplayâ€.*  
> **ä¸­æ–‡**ï¼šæ–¹æ³•å®šä¹‰äº†å¯¹è±¡èƒ½åšä»€ä¹ˆï¼Œä¾‹å¦‚â€œè®¡ç®—â€æˆ–â€œæ˜¾ç¤ºâ€ã€‚

---

### 514. **inheritance** /ÉªnËˆherÉªtÉ™ns/  
**è¯æ—**ï¼šinheritance (n.), inherit (v.)  
**ä¸­æ–‡**ï¼šç»§æ‰¿  
**é«˜é¢‘æ­é…**ï¼š  
- **support inheritance**ï¼šæ”¯æŒç»§æ‰¿  
- **multiple/single inheritance**ï¼šå¤šç»§æ‰¿ï¼å•ç»§æ‰¿  
**ä¾‹å¥**ï¼š  
> *Inheritance allows a new class to reuse code from an existing class.*  
> **ä¸­æ–‡**ï¼šç»§æ‰¿å…è®¸æ–°ç±»å¤ç”¨ç°æœ‰ç±»çš„ä»£ç ã€‚

---

### 515. **encapsulation** /ÉªnËŒkÃ¦psjuËˆleÉªÊƒn/  
**è¯æ—**ï¼šencapsulation (n.), encapsulate (v.)  
**ä¸­æ–‡**ï¼šå°è£…  
**é«˜é¢‘æ­é…**ï¼š  
- **achieve data hiding**ï¼šå®ç°æ•°æ®éšè—  
- **principle of encapsulation**ï¼šå°è£…åŸåˆ™  
**ä¾‹å¥**ï¼š  
> *Encapsulation bundles data and methods together and restricts direct access to internal state.*  
> **ä¸­æ–‡**ï¼šå°è£…å°†æ•°æ®å’Œæ–¹æ³•æ†ç»‘åœ¨ä¸€èµ·ï¼Œå¹¶é™åˆ¶å¯¹å†…éƒ¨çŠ¶æ€çš„ç›´æ¥è®¿é—®ã€‚

---

### 516. **polymorphism** /ËŒpÉ’liËˆmÉ”ËfÉªzÉ™m/  
**è¯æ—**ï¼špolymorphism (n.)  
**ä¸­æ–‡**ï¼šå¤šæ€  
**é«˜é¢‘æ­é…**ï¼š  
- **runtime polymorphism**ï¼šè¿è¡Œæ—¶å¤šæ€  
- **achieve through method overriding**ï¼šé€šè¿‡æ–¹æ³•é‡å†™å®ç°  
**ä¾‹å¥**ï¼š  
> *Polymorphism allows objects of different classes to be treated as instances of a common superclass.*  
> **ä¸­æ–‡**ï¼šå¤šæ€å…è®¸ä¸åŒç±»çš„å¯¹è±¡è¢«å½“ä½œå…±åŒè¶…ç±»çš„å®ä¾‹æ¥å¤„ç†ã€‚

---

### 517. **recursion** /rÉªËˆkÉœËÊƒn/  
**è¯æ—**ï¼šrecursion (n.), recursive (adj.), recurse (v.)  
**ä¸­æ–‡**ï¼šé€’å½’  
**é«˜é¢‘æ­é…**ï¼š  
- **recursive function**ï¼šé€’å½’å‡½æ•°  
- **base case and recursive case**ï¼šåŸºå‡†æƒ…å†µä¸é€’å½’æƒ…å†µ  
**ä¾‹å¥**ï¼š  
> *Recursion is a technique where a function calls itself to solve smaller instances of the same problem.*  
> **ä¸­æ–‡**ï¼šé€’å½’æ˜¯ä¸€ç§å‡½æ•°é€šè¿‡è°ƒç”¨è‡ªèº«æ¥è§£å†³åŒä¸€é—®é¢˜æ›´å°å®ä¾‹çš„æŠ€æœ¯ã€‚

---

### 518. **pointer** /ËˆpÉ”ÉªntÉ™(r)/  
**è¯æ—**ï¼špointer (n.), pointers  
**ä¸­æ–‡**ï¼šæŒ‡é’ˆï¼ˆå­˜å‚¨å†…å­˜åœ°å€çš„å˜é‡ï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **dereference a pointer**ï¼šè§£å¼•ç”¨æŒ‡é’ˆ  
- **pointer arithmetic**ï¼šæŒ‡é’ˆè¿ç®—  
**ä¾‹å¥**ï¼š  
> *In C, pointers allow direct manipulation of memory addresses, offering both power and risk.*  
> **ä¸­æ–‡**ï¼šåœ¨ C è¯­è¨€ä¸­ï¼ŒæŒ‡é’ˆå…è®¸ç›´æ¥æ“ä½œå†…å­˜åœ°å€ï¼Œæ—¢å¼ºå¤§åˆå±é™©ã€‚

---

### 519. **memory** /ËˆmemÉ™ri/  
**è¯æ—**ï¼šmemory (n.), memories  
**ä¸­æ–‡**ï¼šå†…å­˜ï¼›å­˜å‚¨  
**é«˜é¢‘æ­é…**ï¼š  
- **allocate/free memory**ï¼šåˆ†é…ï¼é‡Šæ”¾å†…å­˜  
- **memory leak**ï¼šå†…å­˜æ³„æ¼  
**ä¾‹å¥**ï¼š  
> *Poor memory management can lead to memory leaks, slowing down or crashing the program.*  
> **ä¸­æ–‡**ï¼šå†…å­˜ç®¡ç†ä¸å½“ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ï¼Œä½¿ç¨‹åºå˜æ…¢ç”šè‡³å´©æºƒã€‚

---

### 520. **stack** /stÃ¦k/  
**è¯æ—**ï¼šstack (n./v.), stacks  
**ä¸­æ–‡**ï¼šæ ˆï¼ˆåè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ / å†…å­˜åŒºåŸŸï¼‰  
**é«˜é¢‘æ­é…**ï¼š  
- **call stack**ï¼šè°ƒç”¨æ ˆ  
- **stack overflow**ï¼šæ ˆæº¢å‡º  
**ä¾‹å¥**ï¼š  
> *The call stack keeps track of function calls, and excessive recursion can cause a stack overflow.*  
> **ä¸­æ–‡**ï¼šè°ƒç”¨æ ˆç”¨äºè¿½è¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿‡åº¦é€’å½’å¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºã€‚

---

âœ… **é¢å‘å¯¹è±¡ä¸å†…å­˜æ ¸å¿ƒé€»è¾‘**ï¼š  
> A **class** defines a blueprint; an **object** is its instance. Objects use **methods**, support **inheritance**, hide data via **encapsulation**, and enable flexible design through **polymorphism**. Meanwhile, **recursion** uses the **stack**, and **pointers** manipulate **memory** â€” all requiring careful management to avoid errors like **memory leaks** or **stack overflow**.

---

ä½ å·²æŒæ¡ **520ä¸ªæ ¸å¿ƒè¯æ—**ï¼Œç¼–ç¨‹åŸºç¡€ä½“ç³»åˆæ­¥æˆå‹ï¼

è¯·å›å¤ **â€œç»§ç»­â€**ï¼Œæˆ‘å°†ä¸ºä½ å¸¦æ¥ **#521â€“530**ï¼ˆå°†åŒ…æ‹¬ *queue, linked list, hash table, tree, graph, algorithm complexity, time/space complexity, Big O notation, sorting, searching* ç­‰æ•°æ®ç»“æ„ä¸ç®—æ³•æ ¸å¿ƒè¯ï¼‰ã€‚  
ç»§ç»­æ”€ç™»è®¡ç®—æœºç§‘å­¦é«˜å³°ï¼â›°ï¸ğŸ’»ğŸ“˜