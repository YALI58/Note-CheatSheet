## ğŸ“ŠÂ **ååé‡ (ops/sec) çš„å«ä¹‰**

### **1. æ ¸å¿ƒå®šä¹‰**

**ååé‡**Â = å•ä½æ—¶é—´å†…ç³»ç»ŸæˆåŠŸå¤„ç†çš„**æ“ä½œæ•°é‡**

- **ops**Â = Operations Per Secondï¼ˆæ¯ç§’æ“ä½œæ•°ï¼‰
    
- è¿™é‡Œçš„"æ“ä½œ"æŒ‡**ä½ çš„ä¸šåŠ¡æ“ä½œ**ï¼Œæ¯”å¦‚ï¼š
    
    - æ•°æ®åº“æŸ¥è¯¢/æ›´æ–°
        
    - ç¼“å­˜è¯»å†™
        
    - æ¶ˆæ¯å¤„ç†
        
    - HTTPè¯·æ±‚å¤„ç†
        
    - ä»»ä½•ä½ å†™çš„ä¸šåŠ¡é€»è¾‘



### **3. ååé‡ vs çº¿ç¨‹æ•°**ï¼ˆå…³é”®åŒºåˆ«ï¼ï¼‰

è®©æˆ‘ç”¨ä¸€ä¸ª**é¤å…çš„æ¯”å–»**æ¥è§£é‡Šï¼š

| æ¦‚å¿µ      | é¤å…æ¯”å–»        | Javaå¹¶å‘å¯¹åº”     |
| ------- | ----------- | ------------ |
| **çº¿ç¨‹æ•°** | **æœåŠ¡å‘˜æ•°é‡**   | åŒæ—¶å¤„ç†è¯·æ±‚çš„å·¥ä½œçº¿ç¨‹æ•° |
| **ååé‡** | **æ¯å°æ—¶çš„å®¢äººæ•°** | æ¯ç§’å¤„ç†çš„è¯·æ±‚æ•°     |
| **å»¶è¿Ÿ**  | **é¡¾å®¢ç­‰å¾…æ—¶é—´**  | å•ä¸ªè¯·æ±‚å¤„ç†æ—¶é—´     |



// é”™è¯¯è®¤çŸ¥ï¼šçº¿ç¨‹æ•° = ååé‡
// å®é™…å…³ç³»ï¼š
Threads: 1  â†’ Throughput: 100 ops/sec
Threads: 2  â†’ Throughput: 190 ops/sec  ï¼ˆå¢åŠ 90%ï¼‰
Threads: 4  â†’ Throughput: 350 ops/sec  ï¼ˆå¢åŠ 83%ï¼‰
Threads: 8  â†’ Throughput: 500 ops/sec  ï¼ˆå¢åŠ 43%ï¼‰
Threads: 16 â†’ Throughput: 520 ops/sec  ï¼ˆä»…å¢åŠ 4%ï¼Œæ¥è¿‘ç“¶é¢ˆï¼‰
Threads: 32 â†’ Throughput: 480 ops/sec  âŒ åè€Œä¸‹é™ï¼



```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

public class ThroughputDemo {
    
    // æµ‹è¯•ä»»åŠ¡ï¼šæ¨¡æ‹Ÿä¸€ä¸ªç®€å•çš„ä¸šåŠ¡æ“ä½œ
    static class BusinessTask implements Runnable {
        private final LongAdder completedOps;
        
        BusinessTask(LongAdder counter) {
            this.completedOps = counter;
        }
        
        @Override
        public void run() {
            // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘ï¼ˆè€—æ—¶æ“ä½œï¼‰
            try {
                Thread.sleep(10); // 10mså¤„ç†æ—¶é—´
            } catch (InterruptedException e) {}
            
            // å®Œæˆä¸€ä¸ªæ“ä½œ
            completedOps.increment();
        }
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("çº¿ç¨‹æ•°\tååé‡(ops/sec)\tå»¶è¿Ÿ(ms)");
        System.out.println("-----------------------------------");
        
        // æµ‹è¯•ä¸åŒçº¿ç¨‹æ•°ä¸‹çš„æ€§èƒ½
        for (int threadCount : new int[]{1, 2, 4, 8, 16, 32, 64}) {
            testThroughput(threadCount);
        }
    }
    
    static void testThroughput(int threadCount) throws Exception {
        LongAdder opsCounter = new LongAdder();
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        
        // é¢„çƒ­
        for (int i = 0; i < 100; i++) {
            executor.submit(new BusinessTask(opsCounter));
        }
        Thread.sleep(1000);
        opsCounter.reset();
        
        // æ­£å¼æµ‹è¯•ï¼šè¿è¡Œ5ç§’
        long startTime = System.currentTimeMillis();
        
        // æŒç»­æäº¤ä»»åŠ¡ï¼ˆæ¨¡æ‹Ÿæºæºä¸æ–­çš„è¯·æ±‚ï¼‰
        ScheduledExecutorService submitter = Executors.newSingleThreadScheduledExecutor();
        submitter.scheduleAtFixedRate(() -> {
            for (int i = 0; i < threadCount; i++) {
                executor.submit(new BusinessTask(opsCounter));
            }
        }, 0, 1, TimeUnit.MILLISECONDS);
        
        Thread.sleep(5000); // è¿è¡Œ5ç§’
        
        submitter.shutdown();
        executor.shutdown();
        executor.awaitTermination(2, TimeUnit.SECONDS);
        
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        long totalOps = opsCounter.sum();
        
        // è®¡ç®—ååé‡
        double throughput = totalOps * 1000.0 / duration;
        
        // è®¡ç®—å¹³å‡å»¶è¿Ÿï¼ˆç†è®ºå€¼ï¼‰
        double avgLatency = (threadCount * 10.0) / throughput * 1000;
        
        System.out.printf("%d\t%.0f\t\t%.1f%n", 
            threadCount, throughput, avgLatency);
    }
}
```